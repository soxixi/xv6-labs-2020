/*
要求：使用管道将 2 至 35 中的素数筛选出来
使用 pipe 和 fork 来创建管道。第一个进程将数字 2 到 35 送入管道中。
对于每个质数，你要安排创建一个进程，从其左邻通过管道读取，并在另一条管道上写给右邻。
关闭进程不需要的文件描述符，否则程序将在第一个进程到达 35 之前耗尽 xv6 资源。
*/

/*
提示：
1.关闭进程不需要的文件描述符,否则程序将在第一个进程到达 35 之前耗尽 xv6 资源。
2.一旦第一个进程到达 35 ，它应该等到整个管道终止，包括所有的子进程，孙子进程等。
因此，主进程只有在打印完所有输出后才能退出，即所有其他进程已退出后主进程才能退出。
3.当管道的写入端关闭时， read 函数返回 0 。
4.最简单的方式是直接将 32 位（4 字节）的整型写到管道中，而不是使用格式化的 ASCII I/O 
*/

/*
思路：
①主进程中创建一个管道，将2-11输入到管道中。
②创建一个子进程，读取管道的第1个数2并打印。创建一个新管道，将2的倍数全部筛除，剩下的(3、5、7、9、11)输入新管道中。
②创建一个子子进程，读取管道的第1个数3并打印。创建一个新管道，将3的倍数全部筛除，剩下的(5、7、11)输入新管道中。
···直到所有的数都被筛选完。
*/

// Lab Xv6 and Unix utilities
// primes.c

#include "kernel/types.h"
#include "user/user.h"


// 文件描述符重定向(讲成映射比较好)
void
mapping(int n, int pd[])
{
  // 关闭文件描述符 n
  close(n);
  // 将管道的 读或写 端口复制到描述符 n 上
  // 即产生一个 n 到 pd[n] 的映射
  dup(pd[n]);
  // 关闭管道中的描述符
  close(pd[0]);
  close(pd[1]);
}

// 求素数
void
primes()
{
  // 定义变量获取管道中的数
  int previous, next;
  // 定义管道描述符数组
  int fd[2];
  // 从管道读取数据
  if (read(0, &previous, sizeof(int)))
  {
    // 第一个一定是素数，直接打印
    printf("prime %d\n", previous);
    // 创建管道
    pipe(fd);
    // 创建子进程
    if (fork() == 0)
    {
      // 子进程
      // 子进程将管道的写端口映射到描述符 1 上
      mapping(1, fd);
      // 循环读取管道中的数据
      while (read(0, &next, sizeof(int)))
      {
        // 如果该数不是管道中第一个数的倍数
        if (next % previous != 0)
        {
          // 写入管道
          write(1, &next, sizeof(int));
        }
      }
    }
    else
    {
      // 父进程
      // 等待子进程把数据全部写入管道
      wait(0);
      // 父进程将管道的读端口映射到描述符 0 上
      mapping(0, fd);
      // 递归执行此过程
      primes();
    }  
  }  
}

int 
main(int argc, char *argv[])
{
  // 定义描述符
  int fd[2];
  // 创建管道
  pipe(fd);
  // 创建进程
  if (fork() == 0)
  {
    // 子进程
    // 子进程将管道的写端口映射到描述符 1 上
    mapping(1, fd);
    // 循环获取 2 至 35
    for (int i = 2; i < 36; i++)
    {
      // 将其写入管道
      write(1, &i, sizeof(int));
    }
  }
  else
  {
    // 父进程
    // 等待子进程把数据全部写入管道
    wait(0);
    // 父进程将管道的读端口映射到描述符 0 上
    mapping(0, fd);
    // 调用 primes() 函数求素数
    primes();
  }
  // 正常退出
  exit(0);
}
